#!/usr/bin/env bash
# This script was generated by bashly 1.2.13 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
pgkeen_usage() {
  printf "pgkeen - Postgres Keen CLI for Docker, DB, and User management\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen [OPTIONS] COMMAND\n"
  printf "  pgkeen [COMMAND] --help | -h\n"
  printf "  pgkeen --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Database management commands\n" "db    "
  printf "  %s   Docker management commands\n" "docker"
  printf "  %s   User management commands\n" "user  "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Global Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
pgkeen_db_usage() {
  printf "pgkeen db - Database management commands\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen db COMMAND\n"
  printf "  pgkeen db [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Run ANALYZE on the specified database to update statistics\n" "analyze          "
  printf "  %s   Create a new database with an owner\n" "create           "
  printf "  %s   Drop a database (requires interactive confirmation)\n" "drop             "
  printf "  %s   List all databases in the Postgres server\n" "list             "
  printf "  %s   Show details for a specific database\n" "show             "
  printf "  %s   Run the VACUUM command on the specified database\n" "vacuum           "
  printf "  %s   Enable all extensions in the specified database\n" "enable-extensions"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
pgkeen_db_analyze_usage() {
  printf "pgkeen db analyze - Run ANALYZE on the specified database to update statistics\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen db analyze [DATABASE] [OPTIONS]\n"
  printf "  pgkeen db analyze --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DATABASE"
    printf "    Name of the database to analyze\n"
    echo

  fi
}

# :command.usage
pgkeen_db_create_usage() {
  printf "pgkeen db create - Create a new database with an owner\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen db create DATABASE [OWNER] [OPTIONS]\n"
  printf "  pgkeen db create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DATABASE"
    printf "    Name for the new database\n"
    echo

    # :argument.usage
    printf "  %s\n" "OWNER"
    printf "    User setup as the owner of the database (default: same as database)\n"
    echo

  fi
}

# :command.usage
pgkeen_db_drop_usage() {
  printf "pgkeen db drop - Drop a database (requires interactive confirmation)\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen db drop DATABASE [OPTIONS]\n"
  printf "  pgkeen db drop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DATABASE"
    printf "    Database to drop\n"
    echo

  fi
}

# :command.usage
pgkeen_db_list_usage() {
  printf "pgkeen db list - List all databases in the Postgres server\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen db list [OPTIONS]\n"
  printf "  pgkeen db list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
pgkeen_db_show_usage() {
  printf "pgkeen db show - Show details for a specific database\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen db show DATABASE [OPTIONS]\n"
  printf "  pgkeen db show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DATABASE"
    printf "    Database to show details for inspection\n"
    echo

  fi
}

# :command.usage
pgkeen_db_vacuum_usage() {
  printf "pgkeen db vacuum - Run the VACUUM command on the specified database\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen db vacuum DATABASE [OPTIONS]\n"
  printf "  pgkeen db vacuum --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DATABASE"
    printf "    Database to vacuum\n"
    echo

  fi
}

# :command.usage
pgkeen_db_enable_extensions_usage() {
  printf "pgkeen db enable-extensions - Enable all extensions in the specified database\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen db enable-extensions DATABASE [OPTIONS]\n"
  printf "  pgkeen db enable-extensions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DATABASE"
    printf "    Database to enable extensions in\n"
    echo

  fi
}

# :command.usage
pgkeen_docker_usage() {
  printf "pgkeen docker - Docker management commands\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen docker COMMAND\n"
  printf "  pgkeen docker [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Build the Docker image\n" "build   "
  printf "  %s   Push the Docker image\n" "push    "
  printf "  %s   Reinitialize the docker init.d by clearing out data and restarting the container\n" "reinitdb"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
pgkeen_docker_build_usage() {
  printf "pgkeen docker build - Build the Docker image\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen docker build [DOCKERFILE] [TAG]\n"
  printf "  pgkeen docker build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DOCKERFILE"
    printf "    Path to the Dockerfile (default: 'Dockerfile')\n"
    printf "    %s\n" "Default: ./Dockerfile"
    echo

    # :argument.usage
    printf "  %s\n" "TAG"
    printf "    Tag for the Docker image (default: 'veloper/pgkeen:latest')\n"
    printf "    %s\n" "Default: veloper/pgkeen:latest"
    echo

  fi
}

# :command.usage
pgkeen_docker_push_usage() {
  printf "pgkeen docker push - Push the Docker image\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen docker push [TAG]\n"
  printf "  pgkeen docker push --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TAG"
    printf "    Tag for the Docker image (default: 'veloper/pgkeen:latest')\n"
    printf "    %s\n" "Default: veloper/pgkeen:latest"
    echo

  fi
}

# :command.usage
pgkeen_docker_reinitdb_usage() {
  printf "pgkeen docker reinitdb - Reinitialize the docker init.d by clearing out data and restarting the container\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen docker reinitdb [DOCKER_COMPOSE_FILE] [OPTIONS]\n"
  printf "  pgkeen docker reinitdb --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--data-dir DATA_DIR"
    printf "    Path to the data directory containing the postgresql's data files\n"
    printf "    %s\n" "Default: ./data/pgdata"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DOCKER_COMPOSE_FILE"
    printf "    Path to the Docker Compose file (default: 'docker-compose.yml')\n"
    printf "    %s\n" "Default: ./docker-compose.yml"
    echo

  fi
}

# :command.usage
pgkeen_user_usage() {
  printf "pgkeen user - User management commands\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen user COMMAND\n"
  printf "  pgkeen user [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Create a new postgres user\n" "create      "
  printf "  %s   Drop a user\n" "drop        "
  printf "  %s   List all users in the database\n" "list        "
  printf "  %s   Show details for a specific user\n" "show        "
  printf "  %s   Set or change a user's password\n" "set-password"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
pgkeen_user_create_usage() {
  printf "pgkeen user create - Create a new postgres user\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen user create USERNAME [OPTIONS]\n"
  printf "  pgkeen user create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    Username for the new user\n"
    echo

  fi
}

# :command.usage
pgkeen_user_drop_usage() {
  printf "pgkeen user drop - Drop a user\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen user drop USERNAME [OPTIONS]\n"
  printf "  pgkeen user drop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    Username to drop\n"
    echo

  fi
}

# :command.usage
pgkeen_user_list_usage() {
  printf "pgkeen user list - List all users in the database\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen user list [OPTIONS]\n"
  printf "  pgkeen user list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
pgkeen_user_show_usage() {
  printf "pgkeen user show - Show details for a specific user\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen user show USERNAME [OPTIONS]\n"
  printf "  pgkeen user show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    User to show details for inspection\n"
    echo

  fi
}

# :command.usage
pgkeen_user_set_password_usage() {
  printf "pgkeen user set-password - Set or change a user's password\n\n"

  printf "%s\n" "Usage:"
  printf "  pgkeen user set-password USERNAME [OPTIONS]\n"
  printf "  pgkeen user set-password --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--user USER"
    printf "    Postgres user\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Postgres server host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--port PORT"
    printf "    Postgres server port\n"
    printf "    %s\n" "Default: 5432"
    echo

    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Database to operate on\n"
    printf "    %s\n" "Default: postgres"
    echo

    # :flag.usage
    printf "  %s\n" "--pgpassfile PGPASSFILE"
    printf "    Path to the .pgpass file for password management\n"
    printf "    %s\n" "Default: ${HOME}/.pgpass"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    User whose password will be changed\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh

enable_auto_colors() {
  if [[ -z ${NO_COLOR+x} && ! -t 1 ]]; then
    NO_COLOR=1
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ "${NO_COLOR:-}" == "" ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# src/lib/pgclient.sh
pg_client() {
    source_settings

    local host="${SETTINGS[host]}"
    local port="${SETTINGS[port]}"
    local user="${SETTINGS[user]}"
    local database="${SETTINGS[database]}"

    if [[ -z "$user" || -z "$host" || -z "$port" ]]; then
        echo "[pg_psql] Missing required Postgres connection parameters." >&2
        return 1
    fi

    parts=()

    # Connection parameters
    parts+=("--host=$host")
    parts+=("--port=$port")
    parts+=("--username=$user")

    # If a specific database is provided, use it
    if [[ -n "$database" ]]; then
        parts+=("--dbname=$database")
    fi

    # Never issue a password prompt. If the server requires password authentication and a password is not available from
    # other sources such as a .pgpass file, the connection attempt will fail. This option can be useful in batch jobs
    # and scripts where no user is present to enter a password.
    parts+=("--no-password")

    # Prevent asking for user interaction
    # Note: This also disables readline support so you can't use arrow keys, history, or tab completion
    parts+=("--no-readline")

    # Single Transaction mode
    parts+=("--single-transaction")

    # Echo errors
    parts+=("--echo-errors")

    # Assemble the command
    cmd="${parts[*]}"

    # Execute the command
    # Disable pager
    (
        PAGER="" PSQL_PAGER="" psql $cmd "$@"
    )
}

# == User Management Functions =============================================================

pg_users_list() {
    # List all users in the Postgres database with detailed info
    pg_client -c "SELECT
        usename AS username,
        usesysid AS user_id,
        usecreatedb AS can_create_db,
        usesuper AS is_superuser,
        userepl AS can_replicate,
        (passwd IS NOT NULL) AS has_password,
        valuntil AS password_valid_until,
        useconnlimit AS connection_limit
    FROM pg_user;"
}

pg_users_show() {
    local username="$1"
    if [[ -z "$username" ]]; then
        echo "Username is required." >&2
        return 1
    fi
    # Show details of a specific user
    pg_client -c "SELECT
        usename AS username,
        usesysid AS user_id,
        usecreatedb AS can_create_db,
        usesuper AS is_superuser,
        userepl AS can_replicate,
        (passwd IS NOT NULL) AS has_password,
        valuntil AS password_valid_until,
        useconnlimit AS connection_limit
    FROM pg_user WHERE usename = '$username';"
}

pg_users_create() {
    local username="$1"
    local password="$2"

    if [[ -z "$username" ]]; then
        echo "Username is required." >&2
        return 1
    fi

    if pg_users_exists "$username"; then
        echo "User '$username' already exists." >&2
        return 0
    fi

    info "Creating user '$username' ..."
    if [[ -n "$password" ]]; then
        pg_client -c "CREATE USER \"$username\" WITH PASSWORD '$password';"
    else
        pg_client -c "CREATE USER \"$username\";"
    fi
    if [[ $? -ne 0 ]]; then
        error "Failed to create user '$username'."
        return 1
    fi
    success "User '$username' created successfully."
}

pg_users_drop() {
    local username="$1"
    if [[ -z "$username" ]]; then
        echo "Username is required." >&2
        return 1
    fi
    if ! pg_users_exists "$username"; then
        echo "User '$username' does not exist." >&2
        return 1
    fi
    info "Dropping user '$username' ..."
    pg_client -c "DROP USER \"$username\";"
    if [[ $? -ne 0 ]]; then
        error "Failed to drop user '$username'."
        return 1
    fi
    success "User '$username' dropped successfully."
}

pg_users_set_password() {
    local username="$1"
    local password="$2"

    if [[ -z "$username" || -z "$password" ]]; then
        echo "Username and password are required." >&2
        return 1
    fi

    if ! pg_users_exists "$username"; then
        echo "User '$username' does not exist." >&2
        return 1
    fi

    info "Setting password for user '$username' ..."
    pg_client -c "ALTER USER \"$username\" WITH PASSWORD '$password';"
    if [[ $? -ne 0 ]]; then
        error "Failed to set password for user '$username'."
        return 1
    fi
    success "Password for user '$username' set successfully."

}

pg_users_exists() {
    local username="$1"
    if [[ -z "$username" ]]; then
        echo "Username is required." >&2
        return 1
    fi
    pg_client -t -c "SELECT 1 FROM pg_user WHERE usename = '$username';"
    if [[ $? -eq 0 ]]; then return 0; else return 1; fi
}

# == Database Management Functions =============================================================

pg_databases_analyze() {
    local dbname="$1"
    if [[ -z "$dbname" ]]; then
        echo "Database name is required." >&2
        return 1
    fi
    info "Analyzing database '$dbname' ..."
    pg_client -d "$dbname" -c "ANALYZE;"
    if [[ $? -ne 0 ]]; then
        error "Failed to analyze database '$dbname'."
        return 1
    fi
    success "Database '$dbname' analyzed successfully."
}

pg_databases_vacuum() {
    local dbname="$1"
    if [[ -z "$dbname" ]]; then
        echo "Database name is required." >&2
        return 1
    fi
    info "Vacuuming database '$dbname' ..."
    pg_client -d "$dbname" -c "VACUUM;"
    if [[ $? -ne 0 ]]; then
        error "Failed to vacuum database '$dbname'."
        return 1
    fi
    success "Database '$dbname' vacuumed successfully."
}

pg_databases_list() {
    # List all databases in the Postgres server
    pg_client -c "SELECT
        d.datname AS dbname,
        pg_size_pretty(pg_database_size(d.datname)) AS size,
        d.datdba AS owner_id,
        u.usename AS owner,
        CONCAT(d.datdba, ' (', u.usename, ')') AS owner,
        d.datcollate AS collate,
        d.datctype AS ctype,
        CASE WHEN d.datistemplate THEN 'Yes' ELSE 'No' END AS is_tmpl,
        CASE WHEN d.datallowconn THEN 'Yes' ELSE 'No' END AS can_conn,
        d.datconnlimit AS conn_limit,
        CONCAT(d.dattablespace, ' (', t.spcname, ')') AS tablespace
    FROM pg_database d
    LEFT JOIN pg_user u ON d.datdba = u.usesysid
    LEFT JOIN pg_tablespace t ON d.dattablespace = t.oid";
}

pg_databases_show() {
    local dbname="$1"
    if [[ -z "$dbname" ]]; then
        echo "Database name is required." >&2
        return 1
    fi
    # Show details of a specific database
    pg_client -c "SELECT
        d.datname AS name,
        pg_size_pretty(pg_database_size(d.datname)) AS size,
        d.datdba AS owner_id,
        u.usename AS owner,
        d.encoding,
        d.datcollate AS collate,
        d.datctype AS ctype,
        d.datistemplate AS is_template,
        d.datallowconn AS allow_conn,
        d.datconnlimit AS conn_limit,
        d.datfrozenxid AS frozen_xid,
        d.datminmxid AS min_multixid,
        d.dattablespace AS tablespace_id,
        t.spcname AS tablespace
    FROM pg_database d
    LEFT JOIN pg_user u ON d.datdba = u.usesysid
    LEFT JOIN pg_tablespace t ON d.dattablespace = t.oid
    WHERE d.datname = '$dbname';"
}

pg_databases_create_extension_if_not_exists() {
    local dbname="$1"
    local extension_name="$2"
    if [[ -z "$dbname" || -z "$extension_name" ]]; then
        echo "Database name and extension name are required." >&2
        return 1
    fi
    pg_client -d "$dbname" -c "CREATE EXTENSION IF NOT EXISTS \"$extension_name\";"
}

pg_databases_exists() {
    local dbname="$1"
    if [[ -z "$dbname" ]]; then
        echo "Database name is required." >&2
        return 1
    fi
    pg_client -t -c "SELECT 1 FROM pg_database WHERE datname = '$dbname';"
}

pg_databases_get_owner() {
    local dbname="$1"
    if [[ -z "$dbname" ]]; then
        echo "Database name is required." >&2
        return 1
    fi
    pg_client -t -c "SELECT u.usename FROM pg_database d JOIN pg_user u ON d.datdba = u.usesysid WHERE d.datname = '$dbname';"
}

pg_databases_drop() {
    local dbname="$1"
    if [[ -z "$dbname" ]]; then
        echo "Database name is required." >&2
        return 1
    fi
    if ! pg_databases_exists "$dbname"; then
        echo "Database '$dbname' does not exist." >&2
        return 1
    fi
    info "Dropping database '$dbname' ..."
    pg_client -c "DROP DATABASE \"$dbname\";"
    if [[ $? -ne 0 ]]; then
        error "Failed to drop database '$dbname'."
        return 1
    fi
    success "Database '$dbname' dropped successfully."
}

pg_databases_create() {
    local dbname="$1"
    local owner="$2"

    if [[ -z "$dbname" || -z "$owner" ]]; then
        echo "Database name and owner are required." >&2
        return 1
    fi

    # Ensure user exists before any DB operations
    if ! pg_users_exists "$owner"; then
        info "Creating user '$owner' ..."
        pg_client -c "CREATE USER \"$owner\" WITH PASSWORD NULL;"
        [[ $? -ne 0 ]] && error "Failed to create user '$owner'." && return 1
    else
        info "User '$owner' already exists."
    fi

    if pg_databases_exists "$dbname"; then
        info "Found existing database '$dbname'. Checking owner..."
        local current_owner
        current_owner=$(pg_databases_get_owner "$dbname")
        if [[ "$current_owner" != "$owner" ]]; then
            warning "Database '$dbname' owner is '$current_owner', changing to '$owner' ..."
            pg_client -c "ALTER DATABASE \"$dbname\" OWNER TO \"$owner\";"
            [[ $? -ne 0 ]] && error "Failed to change owner for database '$dbname'." && return 1
            success "Owner of database '$dbname' changed from '$current_owner' to '$owner'."
        else
            info "Database '$dbname' already owned by '$owner'."
        fi
    else
        info "Creating database '$dbname' with owner '$owner' ..."
        pg_client -c "CREATE DATABASE \"$dbname\" OWNER \"$owner\";"
        [[ $? -ne 0 ]] && error "Failed to create database '$dbname'." && return 1
        success "Database '$dbname' created successfully."
    fi

    # Ensure owner has CREATE privilege for extensions
    info "Ensuring '$owner' has CREATE privilege on database '$dbname' for extensions ..."
    pg_client -c "GRANT CREATE ON DATABASE \"$dbname\" TO \"$owner\";"
    [[ $? -ne 0 ]] && error "Failed to grant CREATE privilege on database '$dbname' to '$owner'." && return 1

    success "Database '$dbname' and user '$owner' setup completed successfully."
}

pg_databases_create_all_extensions_if_not_exists() {
    local dbname="$1"
    if [[ -z "$dbname" ]]; then
        echo "Database name is required." >&2
        return 1
    fi

    declare -a extensions=(
        "embedding"
        "vector"
        "age"
        "pg_partman"
        "pg_trgm"
        "http"
        "plpython3u"
        "pg_net"
        "pg_jsonschema"
        "hstore"
        "ltree"
        "dict_int"
        "intarray"
        "intagg"
        "fuzzystrmatch"
        "bloom"
        "uuid-ossp"
        "xml2"
        "pg_hashids"
        "autoinc"
        "address_standardizer_data_us"
        "citext"
        "envvar"
        # Some are missing due to only being able to be installed on the postgres database
        # "pgml"
        # "pg_cron"
        # "pgmq"
        # "vectorize"
    )

    local items="$(printf "%s\n" "${extensions[@]}")"

    for ext in $items; do
        local output=$(pg_client --dbname="$dbname" -c "CREATE EXTENSION IF NOT EXISTS \"$ext\" CASCADE;" 2>&1)
        if [[ -n $output && "$output" != *"already exists"* ]]; then
            warning "Failed to install extension '$ext' in database '$dbname'."
            warning "> Output: $output"
            continue
        else
            success "Extension '$ext' installed."
        fi
    done
}

# src/lib/settings.sh
: <<'UNIX_PRECEDENCE_DOC'
Idiomatic Unix precedence (sometimes called "Unix precedence order"

or "conventional precedence") refers to the order in which a CLI tool

or script resolves configuration values.

The classic idiom is:

  1. Command-line arguments (highest precedence)
  2. Command-line flags
  2. Environment variables
  3. Configuration files
  4. Hard-coded Defaults (lowest precedence)

UNIX_PRECEDENCE_DOC

source_settings() {

    declare -gA SETTINGS=()

    # convert env to lowercase version of themselves using str_to_lower
    # e.g. HOST -> host
    declare -gA env=()
    for k in "${!ENV[@]}"; do
        env["$(str_to_lower "$k")"]="${ENV[$k]}"
    done

    declare -gA arguments=() # args would override the built-in args array
    declare -gA flags=()

    for k in "${!args[@]}"; do
        if [[ "$k" == --* ]]; then
            flags["$(str_to_lower "${k:2}")"]="${args[$k]}"
        elif [[ "$k" == -* ]]; then
            flags["$(str_to_lower "${k:1}")"]="${args[$k]}"
        else
            arguments["$(str_to_lower "$k")"]="${args[$k]}"
        fi
    done

    # Now, we merge into SETTINGS in order of precedence: arguments > flags > env

    for k in "${!env[@]}"; do
        SETTINGS["$k"]="${env[$k]}"
    done

    for k in "${!flags[@]}"; do
        SETTINGS["$k"]="${flags[$k]}"
    done

    for k in "${!arguments[@]}"; do
        SETTINGS["$k"]="${arguments[$k]}"
    done

    # at this point, SETTINGS contains the merged configuration values
    # and can be accessed similarly to args: `value="${SETTINGS[key]}"`

}

# src/lib/status_messages.sh

debug() {
  local message="$1"
  if [[ -n "$message" ]]; then
    if [[ "${NO_COLOR:-}" == "" ]]; then
      printf "%s %s\n" "$(magenta_bold "[DEBUG]")" "$(magenta "$message")"
    else
      printf "[DEBUG] %s\n" "$message"
    fi
  fi
}

info() {
  local message="$1"
  if [[ -n "$message" ]]; then
    if [[ "${NO_COLOR:-}" == "" ]]; then
      printf "%s %s\n" "$(cyan_bold "[INFO]")" "$(cyan "$message")"
    else
      printf "[INFO] %s\n" "$message"
    fi
  fi
}

warning() {
  local message="$1"
  if [[ -n "$message" ]]; then
    if [[ "${NO_COLOR:-}" == "" ]]; then
      printf "%s %s\n" "$(yellow_bold "[WARNING]")" "$(yellow "$message")"
    else
      printf "[WARNING] %s\n" "$message"
    fi
  fi
}

error() {
  local message="$1"
  if [[ -n "$message" ]]; then
    if [[ "${NO_COLOR:-}" == "" ]]; then
      printf "%s %s\n" "$(red_bold "[ERROR]")" "$(red "$message")"
    else
      printf "[ERROR] %s\n" "$message"
    fi
  fi
}

success() {
  local message="$1"
  if [[ -n "$message" ]]; then
    if [[ "${NO_COLOR:-}" == "" ]]; then
      printf "%s %s\n" "$(green_bold "[SUCCESS]")" "$(green "$message")"
    else
      printf "[SUCCESS] %s\n" "$message"
    fi
  fi
}

# src/lib/str.sh
# src/lib/str.sh
# String manipulation and interrogation functions library

str_trim() {
    local input="$1"
    [[ -z "$input" ]] && read -r input
    printf '%s\n' "$input" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
}

# Bitmask constants
CAMEL_CASE=1
SNAKE_CASE=2
SCREAMING_SNAKE_CASE=4
PASCAL_CASE=8
KEBAB_CASE=16
TITLE_CASE=32

str_to_lower() {
    local input="$1"
    [[ -z "$input" ]] && read -r input
    printf '%s\n' "$input" | tr '[:upper:]' '[:lower:]'
}

str_to_upper() {
    local input="$1"
    [[ -z "$input" ]] && read -r input
    printf '%s\n' "$input" | tr '[:lower:]' '[:upper:]'
}

is_snake_case() {
    local input="$1"
    [[ -z "$input" ]] && read -r input
    [[ "$input" =~ ^[a-z][a-z0-9]*(?:_[a-z0-9]+)*$ ]]
}

is_screaming_snake_case() {
    local input="$1"
    [[ -z "$input" ]] && read -r input
    [[ "$input" =~ ^[A-Z][A-Z0-9]*(?:_[A-Z0-9]+)*$ ]]
}

is_pascal_case() {
    local input="$1"
    [[ -z "$input" ]] && read -r input
    [[ "$input" =~ ^([A-Z][a-z0-9]*)+$ ]]
}

is_camel_case() {
    local input="$1"
    [[ -z "$input" ]] && read -r input
    [[ "$input" =~ ^[a-z]+([A-Z][a-z0-9]*)*$ ]]
}

is_kebab_case() {
    local input="$1"
    [[ -z "$input" ]] && read -r input
    [[ "$input" =~ ^[a-z][a-z0-9]*(?:-[a-z0-9]+)*$ ]]
}

is_title_case() {
    local input="$1"
    [[ -z "$input" ]] && read -r input
    [[ "$input" =~ ^([A-Z][a-z0-9]*)( [A-Z][a-z0-9]*)*$ ]]
}

str_is() {
    local input="$1"
    local mask="$2"
    (( mask & CAMEL_CASE ))           && is_camel_case "$input"           && return 0
    (( mask & SNAKE_CASE ))           && is_snake_case "$input"           && return 0
    (( mask & SCREAMING_SNAKE_CASE )) && is_screaming_snake_case "$input" && return 0
    (( mask & PASCAL_CASE ))          && is_pascal_case "$input"          && return 0
    (( mask & KEBAB_CASE ))           && is_kebab_case "$input"           && return 0
    (( mask & TITLE_CASE ))           && is_title_case "$input"           && return 0
    return 1
}

str_to_camel_case() {
    local input="$1"
    local result
    [[ -z "$input" ]] && read -r input

    if str_is "$input" $(( SNAKE_CASE | KEBAB_CASE | SCREAMING_SNAKE_CASE )); then
        result="$(printf '%s\n' "$input" | tr '[:upper:]' '[:lower:]' | awk -F'[_-]' '{
            for(i=1;i<=NF;i++) {
                if(i==1) printf "%s", $i;
                else printf "%s", toupper(substr($i,1,1)) tolower(substr($i,2));
            }
            printf "\n"
        }')"
    elif str_is "$input" $PASCAL_CASE; then
        result="$(printf '%s\n' "$input" | awk '{printf "%s%s\n", tolower(substr($0,1,1)), substr($0,2)}')"
    else
        result="$input"
    fi

    printf '%s\n' "$result"
}

str_to_pascal_case() {
    local input="$1"
    local result
    [[ -z "$input" ]] && read -r input

    if str_is "$input" $(( SNAKE_CASE | KEBAB_CASE | SCREAMING_SNAKE_CASE )); then
        result="$(printf '%s\n' "$input" | tr '[:upper:]' '[:lower:]' | awk -F'[_-]' '{
            for(i=1;i<=NF;i++) {
                printf "%s", toupper(substr($i,1,1)) tolower(substr($i,2));
            }
            printf "\n"
        }')"
    elif str_is "$input" $CAMEL_CASE; then
        result="$(printf '%s\n' "$input" | awk '{printf "%s%s\n", toupper(substr($0,1,1)), substr($0,2)}')"
    else
        result="$input"
    fi

    printf '%s\n' "$result"
}

str_to_screaming_snake_case() {
    local input="$1"
    local result
    [[ -z "$input" ]] && read -r input

    if str_is "$input" $(( SNAKE_CASE | KEBAB_CASE )); then
        result="$(printf '%s\n' "$input" | tr '-' '_' | tr '[:lower:]' '[:upper:]')"
    elif str_is "$input" $(( CAMEL_CASE | PASCAL_CASE )); then
        result="$(printf '%s\n' "$input" | awk '{
            gsub(/([A-Z])/, "_&");
            gsub(/^_/, "");
            print toupper($0)
        }')"
    else
        result="$input"
    fi

    printf '%s\n' "$result"
}

str_to_snake_case() {
    local input="$1"
    local result
    [[ -z "$input" ]] && read -r input

    if str_is "$input" $(( CAMEL_CASE | PASCAL_CASE )); then
        result="$(printf '%s\n' "$input" | awk '{
            gsub(/([A-Z])/, "_&");
            gsub(/^_/, "");
            print tolower($0)
        }')"
    elif str_is "$input" $KEBAB_CASE; then
        result="$(printf '%s\n' "$input" | tr '-' '_' | tr '[:upper:]' '[:lower:]')"
    else
        result="$input"
    fi

    printf '%s\n' "$result"
}

str_to_kebab_case() {
    local input="$1"
    local result
    [[ -z "$input" ]] && read -r input

    if str_is "$input" $(( CAMEL_CASE | PASCAL_CASE )); then
        result="$(printf '%s\n' "$input" | awk '{
            gsub(/([A-Z])/, "-&");
            gsub(/^-/, "");
            print tolower($0)
        }')"
    elif str_is "$input" $SNAKE_CASE; then
        result="$(printf '%s\n' "$input" | tr '_' '-' | tr '[:upper:]' '[:lower:]')"
    else
        result="$input"
    fi

    printf '%s\n' "$result"
}

str_to_title_case() {
    local input="$1"
    local result
    [[ -z "$input" ]] && read -r input

    if str_is "$input" $(( SNAKE_CASE | KEBAB_CASE | SCREAMING_SNAKE_CASE )); then
        result="$(printf '%s\n' "$input" | tr '_-' '  ' | awk '{
            for(i=1;i<=NF;i++) {
                $i = toupper(substr($i,1,1)) tolower(substr($i,2))
            }
            print $0
        }')"
    elif str_is "$input" $CAMEL_CASE; then
        result="$(printf '%s\n' "$input" | awk '{
            gsub(/([A-Z])/, " \\1");
            for(i=1;i<=NF;i++) {
                $i = toupper(substr($i,1,1)) tolower(substr($i,2))
            }
            print $0
        }')"
    else
        result="$input"
    fi

    printf '%s\n' "$result"
}

# :command.command_functions

# :command.function
pgkeen_db_analyze_command() {

  # src/db_analyze_command.sh
  source_settings

  pg_databases_analyze "${SETTINGS[database]}"

}

# :command.function
pgkeen_db_create_command() {

  # src/db_create_command.sh
  database="${args[database]}" # directly from args, not SETTINGS.
  owner="${args[owner]:-database}" # Default owner is the same as the database name.
  pg_databases_create "$database" "$owner"
}

# :command.function
pgkeen_db_drop_command() {

  # src/db_drop_command.sh
  database="${args[database]}"

  warning "This command will drop the database '$database', please type in the database name in all CAPS to confirm:"

  CONFIRMATION=""
  read -r CONFIRMATION

  EXPECTED_CONFIRMATION="$(str_to_upper "$database")"

  if [[ "$CONFIRMATION" != "$EXPECTED_CONFIRMATION" ]]; then
      red "Confirmation failed. Database '$database' was not dropped."
      exit 1
  else
      info "Confirmation successful. Proceeding to drop database '$database'... "
  fi

  # Ensure the database exists before attempting to drop it
  if ! pg_databases_exists "$database"; then
      success "Database '$database' does not exist. Nothing to drop."
      exit 0
  fi

  pg_databases_drop "$database"

}

# :command.function
pgkeen_db_list_command() {

  # src/db_list_command.sh
  pg_databases_list

}

# :command.function
pgkeen_db_show_command() {

  # src/db_show_command.sh
  database="${args[database]}"
  pg_databases_show "$database"
}

# :command.function
pgkeen_db_vacuum_command() {

  # src/db_vacuum_command.sh
  pg_databases_vacuum "${SETTINGS[database]}"

}

# :command.function
pgkeen_db_enable_extensions_command() {

  # src/db_enable_extensions_command.sh
  pg_databases_create_all_extensions_if_not_exists "${args[database]}"

}

# :command.function
pgkeen_docker_build_command() {

  # src/docker_build_command.sh
  # Actual logic from bin/build.sh
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  ROOT_DIR="$(realpath "$SCRIPT_DIR/..")"
  DOCKERFILE="${get_setting dockerfile:-"$ROOT_DIR/Dockerfile"}"
  TAG="${get_setting tag:-"veloper/pgkeen:latest"}"
  PUSH="${get_setting push:-1}"

  cmd="docker build --tag "$TAG" --file "$DOCKERFILE" "$ROOT_DIR""
  if [[ $PUSH -eq 1 ]]; then
      cmd+=" --push"
  fi

  info "Building Docker image: $TAG"
  exec $cmd

}

# :command.function
pgkeen_docker_push_command() {

  # src/docker_push_command.sh
  TAG="${SETTINGS[tag]}"
  info "Pushing Docker image: $TAG"
  exec docker push "$TAG"

}

# :command.function
pgkeen_docker_reinitdb_command() {

  # src/docker_reinitdb_command.sh
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  ROOT_DIR="$(realpath "$SCRIPT_DIR")"

  # Change working directory to the root directory
  # or exit with an error if it fails
  cd "$ROOT_DIR" || exit 1

  DATA_DIR="${ROOT_DIR}/${SETTINGS[data_dir]}"
  DOCKER_COMPOSE_FILE="${ROOT_DIR}/${SETTINGS[docker_compose_file]}"

  info "Checking data directory..."
  if [ ! -d "$DATA_DIR" ]; then
      yellow "Postgres data directory does not exist: $DATA_DIR"
      info "Auto creating data directory..."
      mkdir -p "$DATA_DIR"
  fi
  DATA_DIR="$(realpath "$DATA_DIR")" # real pathing it here

  info "Checking for docker-compose.yml file..."
  if [ ! -f "$DOCKER_COMPOSE_FILE" ]; then
      error "Docker Compose file does not exist: $DOCKER_COMPOSE_FILE" >&2
      error "Please ensure you have a valid docker-compose.yml file in the root directory and try again." >&2
      exit 1
  fi
  DOCKER_COMPOSE_FILE="$(realpath "$DOCKER_COMPOSE_FILE")" # real pathing it here

  info "Checking for running containers..."
  if has_running_containers; then
      yellow "Attempting to stop running containers in $ROOT_DIR..."
      docker-compose down
      if [ $? -ne 0 ]; then
          error "Failed to stop running containers." >&2
          error "Please check your Docker setup and try again." >&2
          exit 1
      fi
  fi

  info "Reinitializing database..."
  debug "This will clear the data directory, which allows the docker image to reinitialize the database."

  # Remove all files in the data directory except .gitkeep
  find "$DATA_DIR" -mindepth 1 ! -name '.gitkeep' -exec rm -rf {} +
  if [ $? -ne 0 ]; then
      error "Failed to clear the data directory: $DATA_DIR" >&2
      error "Please check your permissions or the directory structure and try again." >&2
      exit 1
  fi

  info "Running `docker-compose up` in the background..."
  docker-compose -f "$DOCKER_COMPOSE_FILE" up --detached
  if [ $? -ne 0 ]; then
      error "Failed to start the Docker containers." >&2
      error "Please check your Docker Compose file and try again." >&2
      exit 1
  fi

  info "Tailing container logs in the foreground..."
  info "You may exit with Ctrl+C at any time without stopping the container."
  exec docker-compose -f "$DOCKER_COMPOSE_FILE" logs -f

}

# :command.function
pgkeen_user_create_command() {

  # src/user_create_command.sh
  username="${args[username]}"

  # Check if the username is provided via environment variable or settings
  # if there's still nothing, then hard-fail
  if [[ -z "${ENV[PASSWORD]}" ]]; then
    password=""
  fi

  if [[ -z "$password" ]]; then
    warning "No password provided and thus not password has been set for this user. Be aware if your postgres is configured to allow passwordless access, this user will be able to connect without a password."
  fi

  pg_users_create "$username" "$password"

}

# :command.function
pgkeen_user_drop_command() {

  # src/user_drop_command.sh
  username="${args[username]}"
  pg_users_drop "$username"

}

# :command.function
pgkeen_user_list_command() {

  # src/user_list_command.sh
  pg_users_list
}

# :command.function
pgkeen_user_show_command() {

  # src/user_show_command.sh
  pg_users_show "${SETTINGS[username]}"

}

# :command.function
pgkeen_user_set_password_command() {

  # src/user_set_password_command.sh
  username="${args[username]}"
  if [[ -z "${ENV[PASSWORD]}" ]]; then
    password="${SETTINGS[password]:-''}"
  fi
  pg_users_set_password "$username" "$password"

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        pgkeen_usage
        exit
        ;;

      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    db)
      action="db"
      shift
      pgkeen_db_parse_requirements "$@"
      shift $#
      ;;

    docker)
      action="docker"
      shift
      pgkeen_docker_parse_requirements "$@"
      shift $#
      ;;

    user)
      action="user"
      shift
      pgkeen_user_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      pgkeen_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.parse_requirements
pgkeen_db_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_db_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    analyze)
      action="analyze"
      shift
      pgkeen_db_analyze_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      pgkeen_db_create_parse_requirements "$@"
      shift $#
      ;;

    drop)
      action="drop"
      shift
      pgkeen_db_drop_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      pgkeen_db_list_parse_requirements "$@"
      shift $#
      ;;

    show)
      action="show"
      shift
      pgkeen_db_show_parse_requirements "$@"
      shift $#
      ;;

    vacuum)
      action="vacuum"
      shift
      pgkeen_db_vacuum_parse_requirements "$@"
      shift $#
      ;;

    enable-extensions)
      action="enable-extensions"
      shift
      pgkeen_db_enable_extensions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      pgkeen_db_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pgkeen_db_analyze_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_db_analyze_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="db analyze"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['database']+x} ]]; then
          args['database']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.parse_requirements
pgkeen_db_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_db_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="db create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['database']+x} ]]; then
          args['database']=$1
          shift
        # :argument.case
        elif [[ -z ${args['owner']+x} ]]; then
          args['owner']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['database']+x} ]]; then
    printf "missing required argument: DATABASE\nusage: pgkeen db create DATABASE [OWNER] [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.parse_requirements
pgkeen_db_drop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_db_drop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="db drop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['database']+x} ]]; then
          args['database']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['database']+x} ]]; then
    printf "missing required argument: DATABASE\nusage: pgkeen db drop DATABASE [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.parse_requirements
pgkeen_db_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_db_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="db list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.parse_requirements
pgkeen_db_show_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_db_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="db show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['database']+x} ]]; then
          args['database']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['database']+x} ]]; then
    printf "missing required argument: DATABASE\nusage: pgkeen db show DATABASE [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.parse_requirements
pgkeen_db_vacuum_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_db_vacuum_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="db vacuum"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['database']+x} ]]; then
          args['database']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['database']+x} ]]; then
    printf "missing required argument: DATABASE\nusage: pgkeen db vacuum DATABASE [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.parse_requirements
pgkeen_db_enable_extensions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_db_enable_extensions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="db enable-extensions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['database']+x} ]]; then
          args['database']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['database']+x} ]]; then
    printf "missing required argument: DATABASE\nusage: pgkeen db enable-extensions DATABASE [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.parse_requirements
pgkeen_docker_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_docker_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    build)
      action="build"
      shift
      pgkeen_docker_build_parse_requirements "$@"
      shift $#
      ;;

    push)
      action="push"
      shift
      pgkeen_docker_push_parse_requirements "$@"
      shift $#
      ;;

    reinitdb)
      action="reinitdb"
      shift
      pgkeen_docker_reinitdb_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      pgkeen_docker_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pgkeen_docker_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_docker_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="docker build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['dockerfile']+x} ]]; then
          args['dockerfile']=$1
          shift
        # :argument.case
        elif [[ -z ${args['tag']+x} ]]; then
          args['tag']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['dockerfile']:-} ]] || args['dockerfile']="./Dockerfile"
  [[ -n ${args['tag']:-} ]] || args['tag']="veloper/pgkeen:latest"

}

# :command.parse_requirements
pgkeen_docker_push_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_docker_push_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="docker push"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['tag']+x} ]]; then
          args['tag']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['tag']:-} ]] || args['tag']="veloper/pgkeen:latest"

}

# :command.parse_requirements
pgkeen_docker_reinitdb_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_docker_reinitdb_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="docker reinitdb"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --data-dir)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--data-dir']="$2"
          shift
          shift
        else
          printf "%s\n" "--data-dir requires an argument: --data-dir DATA_DIR" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['docker_compose_file']+x} ]]; then
          args['docker_compose_file']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['docker_compose_file']:-} ]] || args['docker_compose_file']="./docker-compose.yml"
  [[ -n ${args['--data-dir']:-} ]] || args['--data-dir']="./data/pgdata"

}

# :command.parse_requirements
pgkeen_user_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_user_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    create)
      action="create"
      shift
      pgkeen_user_create_parse_requirements "$@"
      shift $#
      ;;

    drop)
      action="drop"
      shift
      pgkeen_user_drop_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      pgkeen_user_list_parse_requirements "$@"
      shift $#
      ;;

    show)
      action="show"
      shift
      pgkeen_user_show_parse_requirements "$@"
      shift $#
      ;;

    set-password)
      action="set-password"
      shift
      pgkeen_user_set_password_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      pgkeen_user_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
pgkeen_user_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_user_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="user create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['username']+x} ]]; then
    printf "missing required argument: USERNAME\nusage: pgkeen user create USERNAME [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.parse_requirements
pgkeen_user_drop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_user_drop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="user drop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['username']+x} ]]; then
    printf "missing required argument: USERNAME\nusage: pgkeen user drop USERNAME [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.parse_requirements
pgkeen_user_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_user_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="user list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.parse_requirements
pgkeen_user_show_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_user_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="user show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['username']+x} ]]; then
    printf "missing required argument: USERNAME\nusage: pgkeen user show USERNAME [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.parse_requirements
pgkeen_user_set_password_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        pgkeen_user_set_password_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="user set-password"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--user']="$2"
          shift
          shift
        else
          printf "%s\n" "--user requires an argument: --user USER" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --port)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--port']="$2"
          shift
          shift
        else
          printf "%s\n" "--port requires an argument: --port PORT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --pgpassfile)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--pgpassfile']="$2"
          shift
          shift
        else
          printf "%s\n" "--pgpassfile requires an argument: --pgpassfile PGPASSFILE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['username']+x} ]]; then
    printf "missing required argument: USERNAME\nusage: pgkeen user set-password USERNAME [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--user']:-} ]] || args['--user']="postgres"
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"
  [[ -n ${args['--port']:-} ]] || args['--port']="5432"
  [[ -n ${args['--database']:-} ]] || args['--database']="postgres"
  [[ -n ${args['--pgpassfile']:-} ]] || args['--pgpassfile']="${HOME}/.pgpass"

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "db") pgkeen_db_command ;;
    "db analyze") pgkeen_db_analyze_command ;;
    "db create") pgkeen_db_create_command ;;
    "db drop") pgkeen_db_drop_command ;;
    "db list") pgkeen_db_list_command ;;
    "db show") pgkeen_db_show_command ;;
    "db vacuum") pgkeen_db_vacuum_command ;;
    "db enable-extensions") pgkeen_db_enable_extensions_command ;;
    "docker") pgkeen_docker_command ;;
    "docker build") pgkeen_docker_build_command ;;
    "docker push") pgkeen_docker_push_command ;;
    "docker reinitdb") pgkeen_docker_reinitdb_command ;;
    "user") pgkeen_user_command ;;
    "user create") pgkeen_user_create_command ;;
    "user drop") pgkeen_user_drop_command ;;
    "user list") pgkeen_user_list_command ;;
    "user show") pgkeen_user_show_command ;;
    "user set-password") pgkeen_user_set_password_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
